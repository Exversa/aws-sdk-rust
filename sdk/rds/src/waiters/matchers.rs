// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// Matcher union: {"output":{"path":"DBClusters[].Status","expected":"available","comparator":"allStringEquals"}}
pub(crate) fn match_describe_db_clusters_72c58ef0321a1929c(
    _result: ::std::result::Result<
        &crate::operation::describe_db_clusters::DescribeDbClustersOutput,
        &crate::operation::describe_db_clusters::DescribeDBClustersError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_clusters::DescribeDbClustersOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_clusters.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbCluster) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "available";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBClusters[].Status","expected":"deleted","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_clusters_fab1869fde25c3e91(
    _result: ::std::result::Result<
        &crate::operation::describe_db_clusters::DescribeDbClustersOutput,
        &crate::operation::describe_db_clusters::DescribeDBClustersError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_clusters::DescribeDbClustersOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_clusters.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbCluster) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "deleted";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBClusters[].Status","expected":"deleting","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_clusters_63551110c8319cd53(
    _result: ::std::result::Result<
        &crate::operation::describe_db_clusters::DescribeDbClustersOutput,
        &crate::operation::describe_db_clusters::DescribeDBClustersError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_clusters::DescribeDbClustersOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_clusters.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbCluster) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "deleting";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBClusters[].Status","expected":"failed","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_clusters_95c1b2832e5ad6ab3(
    _result: ::std::result::Result<
        &crate::operation::describe_db_clusters::DescribeDbClustersOutput,
        &crate::operation::describe_db_clusters::DescribeDBClustersError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_clusters::DescribeDbClustersOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_clusters.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbCluster) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "failed";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBClusters[].Status","expected":"incompatible-restore","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_clusters_ec6b4b3c95fa34758(
    _result: ::std::result::Result<
        &crate::operation::describe_db_clusters::DescribeDbClustersOutput,
        &crate::operation::describe_db_clusters::DescribeDBClustersError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_clusters::DescribeDbClustersOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_clusters.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbCluster) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "incompatible-restore";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBClusters[].Status","expected":"incompatible-parameters","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_clusters_facc13e16e2b3303d(
    _result: ::std::result::Result<
        &crate::operation::describe_db_clusters::DescribeDbClustersOutput,
        &crate::operation::describe_db_clusters::DescribeDBClustersError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_clusters::DescribeDbClustersOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_clusters.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbCluster) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "incompatible-parameters";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"length(DBClusters) == `0`","expected":"true","comparator":"booleanEquals"}}
pub(crate) fn match_describe_db_clusters_d1257803ad6a9c0fa(
    _result: ::std::result::Result<
        &crate::operation::describe_db_clusters::DescribeDbClustersOutput,
        &crate::operation::describe_db_clusters::DescribeDBClustersError,
    >,
) -> bool {
    fn path_traversal<'a>(_output: &'a crate::operation::describe_db_clusters::DescribeDbClustersOutput) -> ::std::option::Option<bool> {
        let _fld_2 = _output.db_clusters.as_ref()?;
        let _ret_1 = _fld_2.len() as i64;
        const _LIT_3: &f64 = &0.0;
        let _tmp_5 = *_LIT_3;
        let _tmp_6 = _tmp_5 as i64;
        let _cmp_4 = _ret_1 == _tmp_6;
        ::std::option::Option::Some(_cmp_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            let right = true;
            let _cmp_1 = value == right;
            _cmp_1
        })
        .unwrap_or_default()
}

/// Matcher union: {"errorType":"DBClusterNotFoundFault"}
pub(crate) fn match_describe_db_clusters_7ee19a877ad11187a(
    _result: ::std::result::Result<
        &crate::operation::describe_db_clusters::DescribeDbClustersOutput,
        &crate::operation::describe_db_clusters::DescribeDBClustersError,
    >,
) -> bool {
    if let ::std::result::Result::Err(err) = _result {
        if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(err) {
            return code == "DBClusterNotFoundFault";
        }
    }
    false
}

/// Matcher union: {"output":{"path":"DBClusters[].Status","expected":"creating","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_clusters_ed1511295bec054f2(
    _result: ::std::result::Result<
        &crate::operation::describe_db_clusters::DescribeDbClustersOutput,
        &crate::operation::describe_db_clusters::DescribeDBClustersError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_clusters::DescribeDbClustersOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_clusters.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbCluster) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "creating";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBClusters[].Status","expected":"modifying","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_clusters_d81b652414f522708(
    _result: ::std::result::Result<
        &crate::operation::describe_db_clusters::DescribeDbClustersOutput,
        &crate::operation::describe_db_clusters::DescribeDBClustersError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_clusters::DescribeDbClustersOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_clusters.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbCluster) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "modifying";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBClusters[].Status","expected":"rebooting","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_clusters_0e021dbb7f83368b4(
    _result: ::std::result::Result<
        &crate::operation::describe_db_clusters::DescribeDbClustersOutput,
        &crate::operation::describe_db_clusters::DescribeDBClustersError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_clusters::DescribeDbClustersOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_clusters.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbCluster) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "rebooting";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBClusters[].Status","expected":"resetting-master-credentials","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_clusters_da3894151799a4aff(
    _result: ::std::result::Result<
        &crate::operation::describe_db_clusters::DescribeDbClustersOutput,
        &crate::operation::describe_db_clusters::DescribeDBClustersError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_clusters::DescribeDbClustersOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_clusters.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbCluster) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "resetting-master-credentials";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBClusterSnapshots[].Status","expected":"available","comparator":"allStringEquals"}}
pub(crate) fn match_describe_db_cluster_snapshots_24cd583c41e1b6f5b(
    _result: ::std::result::Result<
        &crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
        &crate::operation::describe_db_cluster_snapshots::DescribeDBClusterSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_cluster_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbClusterSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "available";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBClusterSnapshots[].Status","expected":"deleted","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_cluster_snapshots_5427b6f5e4914268c(
    _result: ::std::result::Result<
        &crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
        &crate::operation::describe_db_cluster_snapshots::DescribeDBClusterSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_cluster_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbClusterSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "deleted";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBClusterSnapshots[].Status","expected":"deleting","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_cluster_snapshots_af7eba9c0acf7a132(
    _result: ::std::result::Result<
        &crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
        &crate::operation::describe_db_cluster_snapshots::DescribeDBClusterSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_cluster_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbClusterSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "deleting";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBClusterSnapshots[].Status","expected":"failed","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_cluster_snapshots_7dfe0a1282e024903(
    _result: ::std::result::Result<
        &crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
        &crate::operation::describe_db_cluster_snapshots::DescribeDBClusterSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_cluster_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbClusterSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "failed";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBClusterSnapshots[].Status","expected":"incompatible-restore","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_cluster_snapshots_cdbd4a65a155a7bf7(
    _result: ::std::result::Result<
        &crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
        &crate::operation::describe_db_cluster_snapshots::DescribeDBClusterSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_cluster_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbClusterSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "incompatible-restore";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBClusterSnapshots[].Status","expected":"incompatible-parameters","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_cluster_snapshots_48db92f438f307f0d(
    _result: ::std::result::Result<
        &crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
        &crate::operation::describe_db_cluster_snapshots::DescribeDBClusterSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_cluster_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbClusterSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "incompatible-parameters";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"length(DBClusterSnapshots) == `0`","expected":"true","comparator":"booleanEquals"}}
pub(crate) fn match_describe_db_cluster_snapshots_d1a84abc33771364c(
    _result: ::std::result::Result<
        &crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
        &crate::operation::describe_db_cluster_snapshots::DescribeDBClusterSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
    ) -> ::std::option::Option<bool> {
        let _fld_2 = _output.db_cluster_snapshots.as_ref()?;
        let _ret_1 = _fld_2.len() as i64;
        const _LIT_3: &f64 = &0.0;
        let _tmp_5 = *_LIT_3;
        let _tmp_6 = _tmp_5 as i64;
        let _cmp_4 = _ret_1 == _tmp_6;
        ::std::option::Option::Some(_cmp_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            let right = true;
            let _cmp_1 = value == right;
            _cmp_1
        })
        .unwrap_or_default()
}

/// Matcher union: {"errorType":"DBClusterSnapshotNotFoundFault"}
pub(crate) fn match_describe_db_cluster_snapshots_e9936bb62da4082a7(
    _result: ::std::result::Result<
        &crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
        &crate::operation::describe_db_cluster_snapshots::DescribeDBClusterSnapshotsError,
    >,
) -> bool {
    if let ::std::result::Result::Err(err) = _result {
        if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(err) {
            return code == "DBClusterSnapshotNotFoundFault";
        }
    }
    false
}

/// Matcher union: {"output":{"path":"DBClusterSnapshots[].Status","expected":"creating","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_cluster_snapshots_5edd49ba832caf3c1(
    _result: ::std::result::Result<
        &crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
        &crate::operation::describe_db_cluster_snapshots::DescribeDBClusterSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_cluster_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbClusterSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "creating";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBClusterSnapshots[].Status","expected":"modifying","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_cluster_snapshots_5a5994cac8524bc94(
    _result: ::std::result::Result<
        &crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
        &crate::operation::describe_db_cluster_snapshots::DescribeDBClusterSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_cluster_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbClusterSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "modifying";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBClusterSnapshots[].Status","expected":"rebooting","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_cluster_snapshots_5f3facfb716b53409(
    _result: ::std::result::Result<
        &crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
        &crate::operation::describe_db_cluster_snapshots::DescribeDBClusterSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_cluster_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbClusterSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "rebooting";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBClusterSnapshots[].Status","expected":"resetting-master-credentials","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_cluster_snapshots_53930ea56aa42b6f3(
    _result: ::std::result::Result<
        &crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
        &crate::operation::describe_db_cluster_snapshots::DescribeDBClusterSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_cluster_snapshots::DescribeDbClusterSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_cluster_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbClusterSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "resetting-master-credentials";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBInstances[].DBInstanceStatus","expected":"available","comparator":"allStringEquals"}}
pub(crate) fn match_describe_db_instances_1a49e96ac4906b298(
    _result: ::std::result::Result<
        &crate::operation::describe_db_instances::DescribeDbInstancesOutput,
        &crate::operation::describe_db_instances::DescribeDBInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_instances::DescribeDbInstancesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_instances.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbInstance) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.db_instance_status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "available";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBInstances[].DBInstanceStatus","expected":"deleted","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_instances_77e0187886e602da9(
    _result: ::std::result::Result<
        &crate::operation::describe_db_instances::DescribeDbInstancesOutput,
        &crate::operation::describe_db_instances::DescribeDBInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_instances::DescribeDbInstancesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_instances.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbInstance) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.db_instance_status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "deleted";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBInstances[].DBInstanceStatus","expected":"deleting","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_instances_5ec9c383b459d62a0(
    _result: ::std::result::Result<
        &crate::operation::describe_db_instances::DescribeDbInstancesOutput,
        &crate::operation::describe_db_instances::DescribeDBInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_instances::DescribeDbInstancesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_instances.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbInstance) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.db_instance_status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "deleting";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBInstances[].DBInstanceStatus","expected":"failed","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_instances_545820a6bb186e52b(
    _result: ::std::result::Result<
        &crate::operation::describe_db_instances::DescribeDbInstancesOutput,
        &crate::operation::describe_db_instances::DescribeDBInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_instances::DescribeDbInstancesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_instances.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbInstance) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.db_instance_status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "failed";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBInstances[].DBInstanceStatus","expected":"incompatible-restore","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_instances_608daadbd71b65910(
    _result: ::std::result::Result<
        &crate::operation::describe_db_instances::DescribeDbInstancesOutput,
        &crate::operation::describe_db_instances::DescribeDBInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_instances::DescribeDbInstancesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_instances.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbInstance) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.db_instance_status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "incompatible-restore";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBInstances[].DBInstanceStatus","expected":"incompatible-parameters","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_instances_fe252904aec70cd63(
    _result: ::std::result::Result<
        &crate::operation::describe_db_instances::DescribeDbInstancesOutput,
        &crate::operation::describe_db_instances::DescribeDBInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_instances::DescribeDbInstancesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_instances.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbInstance) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.db_instance_status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "incompatible-parameters";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"length(DBInstances) == `0`","expected":"true","comparator":"booleanEquals"}}
pub(crate) fn match_describe_db_instances_6e146202dc53a1aac(
    _result: ::std::result::Result<
        &crate::operation::describe_db_instances::DescribeDbInstancesOutput,
        &crate::operation::describe_db_instances::DescribeDBInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(_output: &'a crate::operation::describe_db_instances::DescribeDbInstancesOutput) -> ::std::option::Option<bool> {
        let _fld_2 = _output.db_instances.as_ref()?;
        let _ret_1 = _fld_2.len() as i64;
        const _LIT_3: &f64 = &0.0;
        let _tmp_5 = *_LIT_3;
        let _tmp_6 = _tmp_5 as i64;
        let _cmp_4 = _ret_1 == _tmp_6;
        ::std::option::Option::Some(_cmp_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            let right = true;
            let _cmp_1 = value == right;
            _cmp_1
        })
        .unwrap_or_default()
}

/// Matcher union: {"errorType":"DBInstanceNotFound"}
pub(crate) fn match_describe_db_instances_44c2cb846aa391790(
    _result: ::std::result::Result<
        &crate::operation::describe_db_instances::DescribeDbInstancesOutput,
        &crate::operation::describe_db_instances::DescribeDBInstancesError,
    >,
) -> bool {
    if let ::std::result::Result::Err(err) = _result {
        if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(err) {
            return code == "DBInstanceNotFound";
        }
    }
    false
}

/// Matcher union: {"output":{"path":"DBInstances[].DBInstanceStatus","expected":"creating","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_instances_bbcaccab59728b5f5(
    _result: ::std::result::Result<
        &crate::operation::describe_db_instances::DescribeDbInstancesOutput,
        &crate::operation::describe_db_instances::DescribeDBInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_instances::DescribeDbInstancesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_instances.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbInstance) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.db_instance_status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "creating";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBInstances[].DBInstanceStatus","expected":"modifying","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_instances_866e8bcc02dcb5d94(
    _result: ::std::result::Result<
        &crate::operation::describe_db_instances::DescribeDbInstancesOutput,
        &crate::operation::describe_db_instances::DescribeDBInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_instances::DescribeDbInstancesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_instances.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbInstance) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.db_instance_status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "modifying";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBInstances[].DBInstanceStatus","expected":"rebooting","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_instances_ceb87a540084b9d41(
    _result: ::std::result::Result<
        &crate::operation::describe_db_instances::DescribeDbInstancesOutput,
        &crate::operation::describe_db_instances::DescribeDBInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_instances::DescribeDbInstancesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_instances.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbInstance) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.db_instance_status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "rebooting";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBInstances[].DBInstanceStatus","expected":"resetting-master-credentials","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_instances_b34d711b975263077(
    _result: ::std::result::Result<
        &crate::operation::describe_db_instances::DescribeDbInstancesOutput,
        &crate::operation::describe_db_instances::DescribeDBInstancesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_instances::DescribeDbInstancesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_instances.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbInstance) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.db_instance_status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "resetting-master-credentials";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBSnapshots[].Status","expected":"available","comparator":"allStringEquals"}}
pub(crate) fn match_describe_db_snapshots_8067a4b185b369b6b(
    _result: ::std::result::Result<
        &crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
        &crate::operation::describe_db_snapshots::DescribeDBSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "available";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBSnapshots[].Status","expected":"deleted","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_snapshots_b93bb1961e898d0f4(
    _result: ::std::result::Result<
        &crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
        &crate::operation::describe_db_snapshots::DescribeDBSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "deleted";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBSnapshots[].Status","expected":"deleting","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_snapshots_fc464f523bab5a59e(
    _result: ::std::result::Result<
        &crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
        &crate::operation::describe_db_snapshots::DescribeDBSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "deleting";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBSnapshots[].Status","expected":"failed","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_snapshots_e19d3e1b7d1929a8c(
    _result: ::std::result::Result<
        &crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
        &crate::operation::describe_db_snapshots::DescribeDBSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "failed";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBSnapshots[].Status","expected":"incompatible-restore","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_snapshots_b232f9340af91f395(
    _result: ::std::result::Result<
        &crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
        &crate::operation::describe_db_snapshots::DescribeDBSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "incompatible-restore";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBSnapshots[].Status","expected":"incompatible-parameters","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_snapshots_cd2d5bd8239288434(
    _result: ::std::result::Result<
        &crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
        &crate::operation::describe_db_snapshots::DescribeDBSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "incompatible-parameters";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"length(DBSnapshots) == `0`","expected":"true","comparator":"booleanEquals"}}
pub(crate) fn match_describe_db_snapshots_c5cf2be8e8581fdf2(
    _result: ::std::result::Result<
        &crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
        &crate::operation::describe_db_snapshots::DescribeDBSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(_output: &'a crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput) -> ::std::option::Option<bool> {
        let _fld_2 = _output.db_snapshots.as_ref()?;
        let _ret_1 = _fld_2.len() as i64;
        const _LIT_3: &f64 = &0.0;
        let _tmp_5 = *_LIT_3;
        let _tmp_6 = _tmp_5 as i64;
        let _cmp_4 = _ret_1 == _tmp_6;
        ::std::option::Option::Some(_cmp_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            let right = true;
            let _cmp_1 = value == right;
            _cmp_1
        })
        .unwrap_or_default()
}

/// Matcher union: {"errorType":"DBSnapshotNotFound"}
pub(crate) fn match_describe_db_snapshots_0b1f7f3adf04a2b45(
    _result: ::std::result::Result<
        &crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
        &crate::operation::describe_db_snapshots::DescribeDBSnapshotsError,
    >,
) -> bool {
    if let ::std::result::Result::Err(err) = _result {
        if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(err) {
            return code == "DBSnapshotNotFound";
        }
    }
    false
}

/// Matcher union: {"output":{"path":"DBSnapshots[].Status","expected":"creating","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_snapshots_73d0c7884e6e6eb30(
    _result: ::std::result::Result<
        &crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
        &crate::operation::describe_db_snapshots::DescribeDBSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "creating";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBSnapshots[].Status","expected":"modifying","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_snapshots_3227ee4bf80486f2b(
    _result: ::std::result::Result<
        &crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
        &crate::operation::describe_db_snapshots::DescribeDBSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "modifying";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBSnapshots[].Status","expected":"rebooting","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_snapshots_38d2148802bb57762(
    _result: ::std::result::Result<
        &crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
        &crate::operation::describe_db_snapshots::DescribeDBSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "rebooting";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"DBSnapshots[].Status","expected":"resetting-master-credentials","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_db_snapshots_809c568fd032effd9(
    _result: ::std::result::Result<
        &crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
        &crate::operation::describe_db_snapshots::DescribeDBSnapshotsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_db_snapshots::DescribeDbSnapshotsOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.db_snapshots.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::DbSnapshot) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "resetting-master-credentials";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"TenantDatabases[].Status","expected":"available","comparator":"allStringEquals"}}
pub(crate) fn match_describe_tenant_databases_3a1dbc6eb46ce3a53(
    _result: ::std::result::Result<
        &crate::operation::describe_tenant_databases::DescribeTenantDatabasesOutput,
        &crate::operation::describe_tenant_databases::DescribeTenantDatabasesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_tenant_databases::DescribeTenantDatabasesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.tenant_databases.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::TenantDatabase) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            !value.is_empty()
                && value.iter().all(|value| {
                    let _tmp_2 = value.as_str();
                    let right = "available";
                    let _cmp_1 = _tmp_2 == right;
                    _cmp_1
                })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"TenantDatabases[].Status","expected":"deleted","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_tenant_databases_0ad44dabc6d308f78(
    _result: ::std::result::Result<
        &crate::operation::describe_tenant_databases::DescribeTenantDatabasesOutput,
        &crate::operation::describe_tenant_databases::DescribeTenantDatabasesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_tenant_databases::DescribeTenantDatabasesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.tenant_databases.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::TenantDatabase) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "deleted";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"TenantDatabases[].Status","expected":"incompatible-parameters","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_tenant_databases_bc89b71f216c7b4b6(
    _result: ::std::result::Result<
        &crate::operation::describe_tenant_databases::DescribeTenantDatabasesOutput,
        &crate::operation::describe_tenant_databases::DescribeTenantDatabasesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_tenant_databases::DescribeTenantDatabasesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.tenant_databases.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::TenantDatabase) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "incompatible-parameters";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"TenantDatabases[].Status","expected":"incompatible-restore","comparator":"anyStringEquals"}}
pub(crate) fn match_describe_tenant_databases_819020f4629ee5588(
    _result: ::std::result::Result<
        &crate::operation::describe_tenant_databases::DescribeTenantDatabasesOutput,
        &crate::operation::describe_tenant_databases::DescribeTenantDatabasesError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_tenant_databases::DescribeTenantDatabasesOutput,
    ) -> ::std::option::Option<::std::vec::Vec<&'a ::std::string::String>> {
        let _fld_1 = _output.tenant_databases.as_ref()?;
        let _prj_3 = _fld_1
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::TenantDatabase) -> ::std::option::Option<&::std::string::String> {
                    let _fld_2 = _v.status.as_ref();
                    _fld_2
                }
                map(v)
            })
            .collect::<::std::vec::Vec<_>>();
        ::std::option::Option::Some(_prj_3)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            value.iter().any(|value| {
                let _tmp_2 = value.as_str();
                let right = "incompatible-restore";
                let _cmp_1 = _tmp_2 == right;
                _cmp_1
            })
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"length(TenantDatabases) == `0`","expected":"true","comparator":"booleanEquals"}}
pub(crate) fn match_describe_tenant_databases_08372e36fefcd8d6c(
    _result: ::std::result::Result<
        &crate::operation::describe_tenant_databases::DescribeTenantDatabasesOutput,
        &crate::operation::describe_tenant_databases::DescribeTenantDatabasesError,
    >,
) -> bool {
    fn path_traversal<'a>(_output: &'a crate::operation::describe_tenant_databases::DescribeTenantDatabasesOutput) -> ::std::option::Option<bool> {
        let _fld_2 = _output.tenant_databases.as_ref()?;
        let _ret_1 = _fld_2.len() as i64;
        const _LIT_3: &f64 = &0.0;
        let _tmp_5 = *_LIT_3;
        let _tmp_6 = _tmp_5 as i64;
        let _cmp_4 = _ret_1 == _tmp_6;
        ::std::option::Option::Some(_cmp_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            let right = true;
            let _cmp_1 = value == right;
            _cmp_1
        })
        .unwrap_or_default()
}

/// Matcher union: {"errorType":"DBInstanceNotFoundFault"}
pub(crate) fn match_describe_tenant_databases_55e791cf20d7fa516(
    _result: ::std::result::Result<
        &crate::operation::describe_tenant_databases::DescribeTenantDatabasesOutput,
        &crate::operation::describe_tenant_databases::DescribeTenantDatabasesError,
    >,
) -> bool {
    if let ::std::result::Result::Err(err) = _result {
        if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(err) {
            return code == "DBInstanceNotFoundFault";
        }
    }
    false
}

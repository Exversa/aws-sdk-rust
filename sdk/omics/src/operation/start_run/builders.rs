// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::start_run::_start_run_output::StartRunOutputBuilder;

pub use crate::operation::start_run::_start_run_input::StartRunInputBuilder;

impl crate::operation::start_run::builders::StartRunInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::start_run::StartRunOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::start_run::StartRunError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.start_run();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `StartRun`.
///
/// <p>Starts a new run or duplicates an existing run.</p>
/// <p>For a new run, specify a unique <code>requestId</code>, the <code>workflowId</code>, and a role ARN. If you're using static run storage (the default), specify the required <code>storageCapacity</code>.</p>
/// <p>You duplicate a run by specifing a unique <code>requestId</code>, the <code>runID</code> of the run to duplicate, and a role ARN.</p>
/// <p>For more information about the optional parameters in the StartRun request, see <a href="https://docs.aws.amazon.com/omics/latest/dev/starting-a-run.html">Starting a run</a> in the <i>Amazon Web Services HealthOmics User Guide</i>.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct StartRunFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::start_run::builders::StartRunInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl crate::client::customize::internal::CustomizableSend<crate::operation::start_run::StartRunOutput, crate::operation::start_run::StartRunError>
    for StartRunFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<crate::operation::start_run::StartRunOutput, crate::operation::start_run::StartRunError>,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl StartRunFluentBuilder {
    /// Creates a new `StartRunFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the StartRun as a reference.
    pub fn as_input(&self) -> &crate::operation::start_run::builders::StartRunInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::start_run::StartRunOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::start_run::StartRunError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::start_run::StartRun::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::start_run::StartRun::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<crate::operation::start_run::StartRunOutput, crate::operation::start_run::StartRunError, Self>
    {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The run's workflow ID.</p>
    pub fn workflow_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.workflow_id(input.into());
        self
    }
    /// <p>The run's workflow ID.</p>
    pub fn set_workflow_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_workflow_id(input);
        self
    }
    /// <p>The run's workflow ID.</p>
    pub fn get_workflow_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_workflow_id()
    }
    /// <p>The run's workflow type.</p>
    pub fn workflow_type(mut self, input: crate::types::WorkflowType) -> Self {
        self.inner = self.inner.workflow_type(input);
        self
    }
    /// <p>The run's workflow type.</p>
    pub fn set_workflow_type(mut self, input: ::std::option::Option<crate::types::WorkflowType>) -> Self {
        self.inner = self.inner.set_workflow_type(input);
        self
    }
    /// <p>The run's workflow type.</p>
    pub fn get_workflow_type(&self) -> &::std::option::Option<crate::types::WorkflowType> {
        self.inner.get_workflow_type()
    }
    /// <p>The ID of a run to duplicate.</p>
    pub fn run_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.run_id(input.into());
        self
    }
    /// <p>The ID of a run to duplicate.</p>
    pub fn set_run_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_run_id(input);
        self
    }
    /// <p>The ID of a run to duplicate.</p>
    pub fn get_run_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_run_id()
    }
    /// <p>A service role for the run.</p>
    pub fn role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.role_arn(input.into());
        self
    }
    /// <p>A service role for the run.</p>
    pub fn set_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_role_arn(input);
        self
    }
    /// <p>A service role for the run.</p>
    pub fn get_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_role_arn()
    }
    /// <p>A name for the run.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// <p>A name for the run.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// <p>A name for the run.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_name()
    }
    /// <p>Identifier of the cache associated with this run. If you don't specify a cache ID, no task outputs are cached for this run.</p>
    pub fn cache_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.cache_id(input.into());
        self
    }
    /// <p>Identifier of the cache associated with this run. If you don't specify a cache ID, no task outputs are cached for this run.</p>
    pub fn set_cache_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_cache_id(input);
        self
    }
    /// <p>Identifier of the cache associated with this run. If you don't specify a cache ID, no task outputs are cached for this run.</p>
    pub fn get_cache_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_cache_id()
    }
    /// <p>The cache behavior for the run. You specify this value if you want to override the default behavior for the cache. You had set the default value when you created the cache. For more information, see <a href="https://docs.aws.amazon.com/omics/latest/dev/how-run-cache.html#run-cache-behavior">Run cache behavior</a> in the Amazon Web Services HealthOmics User Guide.</p>
    pub fn cache_behavior(mut self, input: crate::types::CacheBehavior) -> Self {
        self.inner = self.inner.cache_behavior(input);
        self
    }
    /// <p>The cache behavior for the run. You specify this value if you want to override the default behavior for the cache. You had set the default value when you created the cache. For more information, see <a href="https://docs.aws.amazon.com/omics/latest/dev/how-run-cache.html#run-cache-behavior">Run cache behavior</a> in the Amazon Web Services HealthOmics User Guide.</p>
    pub fn set_cache_behavior(mut self, input: ::std::option::Option<crate::types::CacheBehavior>) -> Self {
        self.inner = self.inner.set_cache_behavior(input);
        self
    }
    /// <p>The cache behavior for the run. You specify this value if you want to override the default behavior for the cache. You had set the default value when you created the cache. For more information, see <a href="https://docs.aws.amazon.com/omics/latest/dev/how-run-cache.html#run-cache-behavior">Run cache behavior</a> in the Amazon Web Services HealthOmics User Guide.</p>
    pub fn get_cache_behavior(&self) -> &::std::option::Option<crate::types::CacheBehavior> {
        self.inner.get_cache_behavior()
    }
    /// <p>The run's group ID.</p>
    pub fn run_group_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.run_group_id(input.into());
        self
    }
    /// <p>The run's group ID.</p>
    pub fn set_run_group_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_run_group_id(input);
        self
    }
    /// <p>The run's group ID.</p>
    pub fn get_run_group_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_run_group_id()
    }
    /// <p>A priority for the run.</p>
    pub fn priority(mut self, input: i32) -> Self {
        self.inner = self.inner.priority(input);
        self
    }
    /// <p>A priority for the run.</p>
    pub fn set_priority(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_priority(input);
        self
    }
    /// <p>A priority for the run.</p>
    pub fn get_priority(&self) -> &::std::option::Option<i32> {
        self.inner.get_priority()
    }
    /// <p>Parameters for the run.</p>
    pub fn parameters(mut self, input: ::aws_smithy_types::Document) -> Self {
        self.inner = self.inner.parameters(input);
        self
    }
    /// <p>Parameters for the run.</p>
    pub fn set_parameters(mut self, input: ::std::option::Option<::aws_smithy_types::Document>) -> Self {
        self.inner = self.inner.set_parameters(input);
        self
    }
    /// <p>Parameters for the run.</p>
    pub fn get_parameters(&self) -> &::std::option::Option<::aws_smithy_types::Document> {
        self.inner.get_parameters()
    }
    /// <p>The static storage capacity (in gibibytes) for this run. This field is not required if the storage type is dynamic (the system ignores any value that you enter).</p>
    pub fn storage_capacity(mut self, input: i32) -> Self {
        self.inner = self.inner.storage_capacity(input);
        self
    }
    /// <p>The static storage capacity (in gibibytes) for this run. This field is not required if the storage type is dynamic (the system ignores any value that you enter).</p>
    pub fn set_storage_capacity(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_storage_capacity(input);
        self
    }
    /// <p>The static storage capacity (in gibibytes) for this run. This field is not required if the storage type is dynamic (the system ignores any value that you enter).</p>
    pub fn get_storage_capacity(&self) -> &::std::option::Option<i32> {
        self.inner.get_storage_capacity()
    }
    /// <p>An output URI for the run.</p>
    pub fn output_uri(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.output_uri(input.into());
        self
    }
    /// <p>An output URI for the run.</p>
    pub fn set_output_uri(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_output_uri(input);
        self
    }
    /// <p>An output URI for the run.</p>
    pub fn get_output_uri(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_output_uri()
    }
    /// <p>A log level for the run.</p>
    pub fn log_level(mut self, input: crate::types::RunLogLevel) -> Self {
        self.inner = self.inner.log_level(input);
        self
    }
    /// <p>A log level for the run.</p>
    pub fn set_log_level(mut self, input: ::std::option::Option<crate::types::RunLogLevel>) -> Self {
        self.inner = self.inner.set_log_level(input);
        self
    }
    /// <p>A log level for the run.</p>
    pub fn get_log_level(&self) -> &::std::option::Option<crate::types::RunLogLevel> {
        self.inner.get_log_level()
    }
    ///
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>Tags for the run.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.tags(k.into(), v.into());
        self
    }
    /// <p>Tags for the run.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p>Tags for the run.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.inner.get_tags()
    }
    /// <p>To ensure that requests don't run multiple times, specify a unique ID for each request.</p>
    pub fn request_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.request_id(input.into());
        self
    }
    /// <p>To ensure that requests don't run multiple times, specify a unique ID for each request.</p>
    pub fn set_request_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_request_id(input);
        self
    }
    /// <p>To ensure that requests don't run multiple times, specify a unique ID for each request.</p>
    pub fn get_request_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_request_id()
    }
    /// <p>The retention mode for the run. The default value is RETAIN.</p>
    /// <p>Amazon Web Services HealthOmics stores a fixed number of runs that are available to the console and API. In the default mode (RETAIN), you need to remove runs manually when the number of run exceeds the maximum. If you set the retention mode to <code>REMOVE</code>, Amazon Web Services HealthOmics automatically removes runs (that have mode set to REMOVE) when the number of run exceeds the maximum. All run logs are available in CloudWatch logs, if you need information about a run that is no longer available to the API.</p>
    /// <p>For more information about retention mode, see <a href="https://docs.aws.amazon.com/omics/latest/dev/starting-a-run.html">Specifying run retention mode</a> in the <i>Amazon Web Services HealthOmics User Guide</i>.</p>
    pub fn retention_mode(mut self, input: crate::types::RunRetentionMode) -> Self {
        self.inner = self.inner.retention_mode(input);
        self
    }
    /// <p>The retention mode for the run. The default value is RETAIN.</p>
    /// <p>Amazon Web Services HealthOmics stores a fixed number of runs that are available to the console and API. In the default mode (RETAIN), you need to remove runs manually when the number of run exceeds the maximum. If you set the retention mode to <code>REMOVE</code>, Amazon Web Services HealthOmics automatically removes runs (that have mode set to REMOVE) when the number of run exceeds the maximum. All run logs are available in CloudWatch logs, if you need information about a run that is no longer available to the API.</p>
    /// <p>For more information about retention mode, see <a href="https://docs.aws.amazon.com/omics/latest/dev/starting-a-run.html">Specifying run retention mode</a> in the <i>Amazon Web Services HealthOmics User Guide</i>.</p>
    pub fn set_retention_mode(mut self, input: ::std::option::Option<crate::types::RunRetentionMode>) -> Self {
        self.inner = self.inner.set_retention_mode(input);
        self
    }
    /// <p>The retention mode for the run. The default value is RETAIN.</p>
    /// <p>Amazon Web Services HealthOmics stores a fixed number of runs that are available to the console and API. In the default mode (RETAIN), you need to remove runs manually when the number of run exceeds the maximum. If you set the retention mode to <code>REMOVE</code>, Amazon Web Services HealthOmics automatically removes runs (that have mode set to REMOVE) when the number of run exceeds the maximum. All run logs are available in CloudWatch logs, if you need information about a run that is no longer available to the API.</p>
    /// <p>For more information about retention mode, see <a href="https://docs.aws.amazon.com/omics/latest/dev/starting-a-run.html">Specifying run retention mode</a> in the <i>Amazon Web Services HealthOmics User Guide</i>.</p>
    pub fn get_retention_mode(&self) -> &::std::option::Option<crate::types::RunRetentionMode> {
        self.inner.get_retention_mode()
    }
    /// <p>The storage type for the run. By default, the run uses STATIC storage type, which allocates a fixed amount of storage. If you set the storage type to DYNAMIC, Amazon Web Services HealthOmics dynamically scales the storage up or down, based on file system utilization. For more information about static and dynamic storage, see <a href="https://docs.aws.amazon.com/omics/latest/dev/Using-workflows.html">Running workflows</a> in the <i>Amazon Web Services HealthOmics User Guide</i>.</p>
    pub fn storage_type(mut self, input: crate::types::StorageType) -> Self {
        self.inner = self.inner.storage_type(input);
        self
    }
    /// <p>The storage type for the run. By default, the run uses STATIC storage type, which allocates a fixed amount of storage. If you set the storage type to DYNAMIC, Amazon Web Services HealthOmics dynamically scales the storage up or down, based on file system utilization. For more information about static and dynamic storage, see <a href="https://docs.aws.amazon.com/omics/latest/dev/Using-workflows.html">Running workflows</a> in the <i>Amazon Web Services HealthOmics User Guide</i>.</p>
    pub fn set_storage_type(mut self, input: ::std::option::Option<crate::types::StorageType>) -> Self {
        self.inner = self.inner.set_storage_type(input);
        self
    }
    /// <p>The storage type for the run. By default, the run uses STATIC storage type, which allocates a fixed amount of storage. If you set the storage type to DYNAMIC, Amazon Web Services HealthOmics dynamically scales the storage up or down, based on file system utilization. For more information about static and dynamic storage, see <a href="https://docs.aws.amazon.com/omics/latest/dev/Using-workflows.html">Running workflows</a> in the <i>Amazon Web Services HealthOmics User Guide</i>.</p>
    pub fn get_storage_type(&self) -> &::std::option::Option<crate::types::StorageType> {
        self.inner.get_storage_type()
    }
    /// <p>The ID of the workflow owner.</p>
    pub fn workflow_owner_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.workflow_owner_id(input.into());
        self
    }
    /// <p>The ID of the workflow owner.</p>
    pub fn set_workflow_owner_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_workflow_owner_id(input);
        self
    }
    /// <p>The ID of the workflow owner.</p>
    pub fn get_workflow_owner_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_workflow_owner_id()
    }
    /// <p>The name of the workflow version.</p>
    pub fn workflow_version_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.workflow_version_name(input.into());
        self
    }
    /// <p>The name of the workflow version.</p>
    pub fn set_workflow_version_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_workflow_version_name(input);
        self
    }
    /// <p>The name of the workflow version.</p>
    pub fn get_workflow_version_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_workflow_version_name()
    }
}

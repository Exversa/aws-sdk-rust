// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// Matcher union: {"output":{"path":"length(AutoScalingGroups) > `0`","expected":"true","comparator":"booleanEquals"}}
pub(crate) fn match_describe_auto_scaling_groups_1e3b20b0d56e629ad(
    _result: ::std::result::Result<
        &crate::operation::describe_auto_scaling_groups::DescribeAutoScalingGroupsOutput,
        &crate::operation::describe_auto_scaling_groups::DescribeAutoScalingGroupsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_auto_scaling_groups::DescribeAutoScalingGroupsOutput,
    ) -> ::std::option::Option<bool> {
        let _fld_2 = _output.auto_scaling_groups.as_ref()?;
        let _ret_1 = _fld_2.len() as i64;
        const _LIT_3: &f64 = &0.0;
        let _tmp_5 = *_LIT_3;
        let _tmp_6 = _tmp_5 as i64;
        let _cmp_4 = _ret_1 > _tmp_6;
        ::std::option::Option::Some(_cmp_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            let right = true;
            let _cmp_1 = value == right;
            _cmp_1
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"length(AutoScalingGroups) > `0`","expected":"false","comparator":"booleanEquals"}}
pub(crate) fn match_describe_auto_scaling_groups_10c2a0c442832fe5f(
    _result: ::std::result::Result<
        &crate::operation::describe_auto_scaling_groups::DescribeAutoScalingGroupsOutput,
        &crate::operation::describe_auto_scaling_groups::DescribeAutoScalingGroupsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_auto_scaling_groups::DescribeAutoScalingGroupsOutput,
    ) -> ::std::option::Option<bool> {
        let _fld_2 = _output.auto_scaling_groups.as_ref()?;
        let _ret_1 = _fld_2.len() as i64;
        const _LIT_3: &f64 = &0.0;
        let _tmp_5 = *_LIT_3;
        let _tmp_6 = _tmp_5 as i64;
        let _cmp_4 = _ret_1 > _tmp_6;
        ::std::option::Option::Some(_cmp_4)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            let right = false;
            let _cmp_1 = value == right;
            _cmp_1
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"contains(AutoScalingGroups[].[length(Instances[?LifecycleState=='InService']) >= MinSize][], `false`)","expected":"false","comparator":"booleanEquals"}}
pub(crate) fn match_describe_auto_scaling_groups_2b8809e69e59ad32a(
    _result: ::std::result::Result<
        &crate::operation::describe_auto_scaling_groups::DescribeAutoScalingGroupsOutput,
        &crate::operation::describe_auto_scaling_groups::DescribeAutoScalingGroupsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_auto_scaling_groups::DescribeAutoScalingGroupsOutput,
    ) -> ::std::option::Option<bool> {
        let _fld_2 = _output.auto_scaling_groups.as_ref()?;
        let _prj_12 = _fld_2
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::AutoScalingGroup) -> ::std::option::Option<::std::vec::Vec<bool>> {
                    let _fld_4 = _v.instances.as_ref()?;
                    let _fprj_8 = _fld_4
                        .iter()
                        .filter({
                            fn filter(_v: &crate::types::Instance) -> ::std::option::Option<bool> {
                                let _fld_5 = _v.lifecycle_state.as_ref()?;
                                let _tmp_14 = _fld_5.as_str();
                                const _LIT_6: &str = "InService";
                                let _cmp_7 = _tmp_14 == _LIT_6;
                                ::std::option::Option::Some(_cmp_7)
                            }
                            |v| filter(v).unwrap_or_default()
                        })
                        .collect::<::std::vec::Vec<_>>();
                    let _ret_3 = _fprj_8.len() as i64;
                    let _fld_9 = _v.min_size.as_ref()?;
                    let _tmp_15 = *_fld_9;
                    let _tmp_16 = _tmp_15 as i64;
                    let _cmp_10 = _ret_3 >= _tmp_16;
                    let _msl_11 = vec![_cmp_10];
                    ::std::option::Option::Some(_msl_11)
                }
                map(v)
            })
            .flatten()
            .collect::<::std::vec::Vec<_>>();
        const _LIT_13: &bool = &false;
        let _ret_1 = _prj_12.iter().any(|_v| {
            let _tmp_18 = *_v;
            let _tmp_19 = *_LIT_13;
            let _cmp_17 = _tmp_18 == _tmp_19;
            _cmp_17
        });
        ::std::option::Option::Some(_ret_1)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            let right = false;
            let _cmp_1 = value == right;
            _cmp_1
        })
        .unwrap_or_default()
}

/// Matcher union: {"output":{"path":"contains(AutoScalingGroups[].[length(Instances[?LifecycleState=='InService']) >= MinSize][], `false`)","expected":"true","comparator":"booleanEquals"}}
pub(crate) fn match_describe_auto_scaling_groups_ab0cd1b1c8e0267b1(
    _result: ::std::result::Result<
        &crate::operation::describe_auto_scaling_groups::DescribeAutoScalingGroupsOutput,
        &crate::operation::describe_auto_scaling_groups::DescribeAutoScalingGroupsError,
    >,
) -> bool {
    fn path_traversal<'a>(
        _output: &'a crate::operation::describe_auto_scaling_groups::DescribeAutoScalingGroupsOutput,
    ) -> ::std::option::Option<bool> {
        let _fld_2 = _output.auto_scaling_groups.as_ref()?;
        let _prj_12 = _fld_2
            .iter()
            .flat_map(|v| {
                #[allow(clippy::let_and_return)]
                fn map(_v: &crate::types::AutoScalingGroup) -> ::std::option::Option<::std::vec::Vec<bool>> {
                    let _fld_4 = _v.instances.as_ref()?;
                    let _fprj_8 = _fld_4
                        .iter()
                        .filter({
                            fn filter(_v: &crate::types::Instance) -> ::std::option::Option<bool> {
                                let _fld_5 = _v.lifecycle_state.as_ref()?;
                                let _tmp_14 = _fld_5.as_str();
                                const _LIT_6: &str = "InService";
                                let _cmp_7 = _tmp_14 == _LIT_6;
                                ::std::option::Option::Some(_cmp_7)
                            }
                            |v| filter(v).unwrap_or_default()
                        })
                        .collect::<::std::vec::Vec<_>>();
                    let _ret_3 = _fprj_8.len() as i64;
                    let _fld_9 = _v.min_size.as_ref()?;
                    let _tmp_15 = *_fld_9;
                    let _tmp_16 = _tmp_15 as i64;
                    let _cmp_10 = _ret_3 >= _tmp_16;
                    let _msl_11 = vec![_cmp_10];
                    ::std::option::Option::Some(_msl_11)
                }
                map(v)
            })
            .flatten()
            .collect::<::std::vec::Vec<_>>();
        const _LIT_13: &bool = &false;
        let _ret_1 = _prj_12.iter().any(|_v| {
            let _tmp_18 = *_v;
            let _tmp_19 = *_LIT_13;
            let _cmp_17 = _tmp_18 == _tmp_19;
            _cmp_17
        });
        ::std::option::Option::Some(_ret_1)
    }
    _result
        .as_ref()
        .ok()
        .and_then(|output| path_traversal(output))
        .map(|value| {
            let right = true;
            let _cmp_1 = value == right;
            _cmp_1
        })
        .unwrap_or_default()
}

// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_service_level_objective::_create_service_level_objective_output::CreateServiceLevelObjectiveOutputBuilder;

pub use crate::operation::create_service_level_objective::_create_service_level_objective_input::CreateServiceLevelObjectiveInputBuilder;

impl crate::operation::create_service_level_objective::builders::CreateServiceLevelObjectiveInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_service_level_objective::CreateServiceLevelObjectiveOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_service_level_objective::CreateServiceLevelObjectiveError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_service_level_objective();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateServiceLevelObjective`.
///
/// <p>Creates a service level objective (SLO), which can help you ensure that your critical business operations are meeting customer expectations. Use SLOs to set and track specific target levels for the reliability and availability of your applications and services. SLOs use service level indicators (SLIs) to calculate whether the application is performing at the level that you want.</p>
/// <p>Create an SLO to set a target for a service or operationâ€™s availability or latency. CloudWatch measures this target frequently you can find whether it has been breached.</p>
/// <p>The target performance quality that is defined for an SLO is the <i>attainment goal</i>.</p>
/// <p>You can set SLO targets for your applications that are discovered by Application Signals, using critical metrics such as latency and availability. You can also set SLOs against any CloudWatch metric or math expression that produces a time series.</p><note>
/// <p>You can't create an SLO for a service operation that was discovered by Application Signals until after that operation has reported standard metrics to Application Signals.</p>
/// </note>
/// <p>When you create an SLO, you specify whether it is a <i>period-based SLO</i> or a <i>request-based SLO</i>. Each type of SLO has a different way of evaluating your application's performance against its attainment goal.</p>
/// <ul>
/// <li>
/// <p>A <i>period-based SLO</i> uses defined <i>periods</i> of time within a specified total time interval. For each period of time, Application Signals determines whether the application met its goal. The attainment rate is calculated as the <code>number of good periods/number of total periods</code>.</p>
/// <p>For example, for a period-based SLO, meeting an attainment goal of 99.9% means that within your interval, your application must meet its performance goal during at least 99.9% of the time periods.</p></li>
/// <li>
/// <p>A <i>request-based SLO</i> doesn't use pre-defined periods of time. Instead, the SLO measures <code>number of good requests/number of total requests</code> during the interval. At any time, you can find the ratio of good requests to total requests for the interval up to the time stamp that you specify, and measure that ratio against the goal set in your SLO.</p></li>
/// </ul>
/// <p>After you have created an SLO, you can retrieve error budget reports for it. An <i>error budget</i> is the amount of time or amount of requests that your application can be non-compliant with the SLO's goal, and still have your application meet the goal.</p>
/// <ul>
/// <li>
/// <p>For a period-based SLO, the error budget starts at a number defined by the highest number of periods that can fail to meet the threshold, while still meeting the overall goal. The <i>remaining error budget</i> decreases with every failed period that is recorded. The error budget within one interval can never increase.</p>
/// <p>For example, an SLO with a threshold that 99.95% of requests must be completed under 2000ms every month translates to an error budget of 21.9 minutes of downtime per month.</p></li>
/// <li>
/// <p>For a request-based SLO, the remaining error budget is dynamic and can increase or decrease, depending on the ratio of good requests to total requests.</p></li>
/// </ul>
/// <p>For more information about SLOs, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-ServiceLevelObjectives.html"> Service level objectives (SLOs)</a>.</p>
/// <p>When you perform a <code>CreateServiceLevelObjective</code> operation, Application Signals creates the <i>AWSServiceRoleForCloudWatchApplicationSignals</i> service-linked role, if it doesn't already exist in your account. This service- linked role has the following permissions:</p>
/// <ul>
/// <li>
/// <p><code>xray:GetServiceGraph</code></p></li>
/// <li>
/// <p><code>logs:StartQuery</code></p></li>
/// <li>
/// <p><code>logs:GetQueryResults</code></p></li>
/// <li>
/// <p><code>cloudwatch:GetMetricData</code></p></li>
/// <li>
/// <p><code>cloudwatch:ListMetrics</code></p></li>
/// <li>
/// <p><code>tag:GetResources</code></p></li>
/// <li>
/// <p><code>autoscaling:DescribeAutoScalingGroups</code></p></li>
/// </ul>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateServiceLevelObjectiveFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_service_level_objective::builders::CreateServiceLevelObjectiveInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_service_level_objective::CreateServiceLevelObjectiveOutput,
        crate::operation::create_service_level_objective::CreateServiceLevelObjectiveError,
    > for CreateServiceLevelObjectiveFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_service_level_objective::CreateServiceLevelObjectiveOutput,
            crate::operation::create_service_level_objective::CreateServiceLevelObjectiveError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateServiceLevelObjectiveFluentBuilder {
    /// Creates a new `CreateServiceLevelObjectiveFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateServiceLevelObjective as a reference.
    pub fn as_input(&self) -> &crate::operation::create_service_level_objective::builders::CreateServiceLevelObjectiveInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_service_level_objective::CreateServiceLevelObjectiveOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_service_level_objective::CreateServiceLevelObjectiveError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_service_level_objective::CreateServiceLevelObjective::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_service_level_objective::CreateServiceLevelObjective::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_service_level_objective::CreateServiceLevelObjectiveOutput,
        crate::operation::create_service_level_objective::CreateServiceLevelObjectiveError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>A name for this SLO.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// <p>A name for this SLO.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// <p>A name for this SLO.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_name()
    }
    /// <p>An optional description for this SLO.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.description(input.into());
        self
    }
    /// <p>An optional description for this SLO.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_description(input);
        self
    }
    /// <p>An optional description for this SLO.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_description()
    }
    /// <p>If this SLO is a period-based SLO, this structure defines the information about what performance metric this SLO will monitor.</p>
    /// <p>You can't specify both <code>RequestBasedSliConfig</code> and <code>SliConfig</code> in the same operation.</p>
    pub fn sli_config(mut self, input: crate::types::ServiceLevelIndicatorConfig) -> Self {
        self.inner = self.inner.sli_config(input);
        self
    }
    /// <p>If this SLO is a period-based SLO, this structure defines the information about what performance metric this SLO will monitor.</p>
    /// <p>You can't specify both <code>RequestBasedSliConfig</code> and <code>SliConfig</code> in the same operation.</p>
    pub fn set_sli_config(mut self, input: ::std::option::Option<crate::types::ServiceLevelIndicatorConfig>) -> Self {
        self.inner = self.inner.set_sli_config(input);
        self
    }
    /// <p>If this SLO is a period-based SLO, this structure defines the information about what performance metric this SLO will monitor.</p>
    /// <p>You can't specify both <code>RequestBasedSliConfig</code> and <code>SliConfig</code> in the same operation.</p>
    pub fn get_sli_config(&self) -> &::std::option::Option<crate::types::ServiceLevelIndicatorConfig> {
        self.inner.get_sli_config()
    }
    /// <p>If this SLO is a request-based SLO, this structure defines the information about what performance metric this SLO will monitor.</p>
    /// <p>You can't specify both <code>RequestBasedSliConfig</code> and <code>SliConfig</code> in the same operation.</p>
    pub fn request_based_sli_config(mut self, input: crate::types::RequestBasedServiceLevelIndicatorConfig) -> Self {
        self.inner = self.inner.request_based_sli_config(input);
        self
    }
    /// <p>If this SLO is a request-based SLO, this structure defines the information about what performance metric this SLO will monitor.</p>
    /// <p>You can't specify both <code>RequestBasedSliConfig</code> and <code>SliConfig</code> in the same operation.</p>
    pub fn set_request_based_sli_config(mut self, input: ::std::option::Option<crate::types::RequestBasedServiceLevelIndicatorConfig>) -> Self {
        self.inner = self.inner.set_request_based_sli_config(input);
        self
    }
    /// <p>If this SLO is a request-based SLO, this structure defines the information about what performance metric this SLO will monitor.</p>
    /// <p>You can't specify both <code>RequestBasedSliConfig</code> and <code>SliConfig</code> in the same operation.</p>
    pub fn get_request_based_sli_config(&self) -> &::std::option::Option<crate::types::RequestBasedServiceLevelIndicatorConfig> {
        self.inner.get_request_based_sli_config()
    }
    /// <p>This structure contains the attributes that determine the goal of the SLO.</p>
    pub fn goal(mut self, input: crate::types::Goal) -> Self {
        self.inner = self.inner.goal(input);
        self
    }
    /// <p>This structure contains the attributes that determine the goal of the SLO.</p>
    pub fn set_goal(mut self, input: ::std::option::Option<crate::types::Goal>) -> Self {
        self.inner = self.inner.set_goal(input);
        self
    }
    /// <p>This structure contains the attributes that determine the goal of the SLO.</p>
    pub fn get_goal(&self) -> &::std::option::Option<crate::types::Goal> {
        self.inner.get_goal()
    }
    ///
    /// Appends an item to `Tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A list of key-value pairs to associate with the SLO. You can associate as many as 50 tags with an SLO. To be able to associate tags with the SLO when you create the SLO, you must have the <code>cloudwatch:TagResource</code> permission.</p>
    /// <p>Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        self.inner = self.inner.tags(input);
        self
    }
    /// <p>A list of key-value pairs to associate with the SLO. You can associate as many as 50 tags with an SLO. To be able to associate tags with the SLO when you create the SLO, you must have the <code>cloudwatch:TagResource</code> permission.</p>
    /// <p>Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p>A list of key-value pairs to associate with the SLO. You can associate as many as 50 tags with an SLO. To be able to associate tags with the SLO when you create the SLO, you must have the <code>cloudwatch:TagResource</code> permission.</p>
    /// <p>Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        self.inner.get_tags()
    }
    ///
    /// Appends an item to `BurnRateConfigurations`.
    ///
    /// To override the contents of this collection use [`set_burn_rate_configurations`](Self::set_burn_rate_configurations).
    ///
    /// <p>Use this array to create <i>burn rates</i> for this SLO. Each burn rate is a metric that indicates how fast the service is consuming the error budget, relative to the attainment goal of the SLO.</p>
    pub fn burn_rate_configurations(mut self, input: crate::types::BurnRateConfiguration) -> Self {
        self.inner = self.inner.burn_rate_configurations(input);
        self
    }
    /// <p>Use this array to create <i>burn rates</i> for this SLO. Each burn rate is a metric that indicates how fast the service is consuming the error budget, relative to the attainment goal of the SLO.</p>
    pub fn set_burn_rate_configurations(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::BurnRateConfiguration>>) -> Self {
        self.inner = self.inner.set_burn_rate_configurations(input);
        self
    }
    /// <p>Use this array to create <i>burn rates</i> for this SLO. Each burn rate is a metric that indicates how fast the service is consuming the error budget, relative to the attainment goal of the SLO.</p>
    pub fn get_burn_rate_configurations(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::BurnRateConfiguration>> {
        self.inner.get_burn_rate_configurations()
    }
}

// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct TerminateGameSessionInput {
    /// <p>A unique identifier for the game session to be terminated. A game session ARN has the following format: <code>arn:aws:gamelift:<region>
    /// ::gamesession/
    /// <fleet id>
    /// /
    /// <custom id string or idempotency token></custom>
    /// </fleet>
    /// </region></code>.</p>
    pub game_session_id: ::std::option::Option<::std::string::String>,
    /// <p>The method to use to terminate the game session. Available methods include:</p>
    /// <ul>
    /// <li>
    /// <p><code>TRIGGER_ON_PROCESS_TERMINATE</code> – Sends an <code>OnProcessTerminate()</code> callback to the server process to initiate the normal game session shutdown sequence. At a minimum, the callback method must include a call to the server SDK action <code>ProcessEnding()</code>, which is how the server process signals that a game session is ending. If the server process doesn't call <code>ProcessEnding()</code>, this termination method won't be successful.</p></li>
    /// <li>
    /// <p><code>FORCE_TERMINATE</code> – Takes action to stop the server process, using existing methods to control how server processes run on an Amazon GameLift managed compute.</p><note>
    /// <p>This method is not available for game sessions that are running on Anywhere fleets unless the fleet is deployed with the Amazon GameLift Agent. In this scenario, a force terminate request results in an invalid or bad request exception.</p>
    /// </note></li>
    /// </ul>
    pub termination_mode: ::std::option::Option<crate::types::TerminationMode>,
}
impl TerminateGameSessionInput {
    /// <p>A unique identifier for the game session to be terminated. A game session ARN has the following format: <code>arn:aws:gamelift:<region>
    /// ::gamesession/
    /// <fleet id>
    /// /
    /// <custom id string or idempotency token></custom>
    /// </fleet>
    /// </region></code>.</p>
    pub fn game_session_id(&self) -> ::std::option::Option<&str> {
        self.game_session_id.as_deref()
    }
    /// <p>The method to use to terminate the game session. Available methods include:</p>
    /// <ul>
    /// <li>
    /// <p><code>TRIGGER_ON_PROCESS_TERMINATE</code> – Sends an <code>OnProcessTerminate()</code> callback to the server process to initiate the normal game session shutdown sequence. At a minimum, the callback method must include a call to the server SDK action <code>ProcessEnding()</code>, which is how the server process signals that a game session is ending. If the server process doesn't call <code>ProcessEnding()</code>, this termination method won't be successful.</p></li>
    /// <li>
    /// <p><code>FORCE_TERMINATE</code> – Takes action to stop the server process, using existing methods to control how server processes run on an Amazon GameLift managed compute.</p><note>
    /// <p>This method is not available for game sessions that are running on Anywhere fleets unless the fleet is deployed with the Amazon GameLift Agent. In this scenario, a force terminate request results in an invalid or bad request exception.</p>
    /// </note></li>
    /// </ul>
    pub fn termination_mode(&self) -> ::std::option::Option<&crate::types::TerminationMode> {
        self.termination_mode.as_ref()
    }
}
impl TerminateGameSessionInput {
    /// Creates a new builder-style object to manufacture [`TerminateGameSessionInput`](crate::operation::terminate_game_session::TerminateGameSessionInput).
    pub fn builder() -> crate::operation::terminate_game_session::builders::TerminateGameSessionInputBuilder {
        crate::operation::terminate_game_session::builders::TerminateGameSessionInputBuilder::default()
    }
}

/// A builder for [`TerminateGameSessionInput`](crate::operation::terminate_game_session::TerminateGameSessionInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct TerminateGameSessionInputBuilder {
    pub(crate) game_session_id: ::std::option::Option<::std::string::String>,
    pub(crate) termination_mode: ::std::option::Option<crate::types::TerminationMode>,
}
impl TerminateGameSessionInputBuilder {
    /// <p>A unique identifier for the game session to be terminated. A game session ARN has the following format: <code>arn:aws:gamelift:<region>
    /// ::gamesession/
    /// <fleet id>
    /// /
    /// <custom id string or idempotency token></custom>
    /// </fleet>
    /// </region></code>.</p>
    /// This field is required.
    pub fn game_session_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.game_session_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique identifier for the game session to be terminated. A game session ARN has the following format: <code>arn:aws:gamelift:<region>
    /// ::gamesession/
    /// <fleet id>
    /// /
    /// <custom id string or idempotency token></custom>
    /// </fleet>
    /// </region></code>.</p>
    pub fn set_game_session_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.game_session_id = input;
        self
    }
    /// <p>A unique identifier for the game session to be terminated. A game session ARN has the following format: <code>arn:aws:gamelift:<region>
    /// ::gamesession/
    /// <fleet id>
    /// /
    /// <custom id string or idempotency token></custom>
    /// </fleet>
    /// </region></code>.</p>
    pub fn get_game_session_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.game_session_id
    }
    /// <p>The method to use to terminate the game session. Available methods include:</p>
    /// <ul>
    /// <li>
    /// <p><code>TRIGGER_ON_PROCESS_TERMINATE</code> – Sends an <code>OnProcessTerminate()</code> callback to the server process to initiate the normal game session shutdown sequence. At a minimum, the callback method must include a call to the server SDK action <code>ProcessEnding()</code>, which is how the server process signals that a game session is ending. If the server process doesn't call <code>ProcessEnding()</code>, this termination method won't be successful.</p></li>
    /// <li>
    /// <p><code>FORCE_TERMINATE</code> – Takes action to stop the server process, using existing methods to control how server processes run on an Amazon GameLift managed compute.</p><note>
    /// <p>This method is not available for game sessions that are running on Anywhere fleets unless the fleet is deployed with the Amazon GameLift Agent. In this scenario, a force terminate request results in an invalid or bad request exception.</p>
    /// </note></li>
    /// </ul>
    /// This field is required.
    pub fn termination_mode(mut self, input: crate::types::TerminationMode) -> Self {
        self.termination_mode = ::std::option::Option::Some(input);
        self
    }
    /// <p>The method to use to terminate the game session. Available methods include:</p>
    /// <ul>
    /// <li>
    /// <p><code>TRIGGER_ON_PROCESS_TERMINATE</code> – Sends an <code>OnProcessTerminate()</code> callback to the server process to initiate the normal game session shutdown sequence. At a minimum, the callback method must include a call to the server SDK action <code>ProcessEnding()</code>, which is how the server process signals that a game session is ending. If the server process doesn't call <code>ProcessEnding()</code>, this termination method won't be successful.</p></li>
    /// <li>
    /// <p><code>FORCE_TERMINATE</code> – Takes action to stop the server process, using existing methods to control how server processes run on an Amazon GameLift managed compute.</p><note>
    /// <p>This method is not available for game sessions that are running on Anywhere fleets unless the fleet is deployed with the Amazon GameLift Agent. In this scenario, a force terminate request results in an invalid or bad request exception.</p>
    /// </note></li>
    /// </ul>
    pub fn set_termination_mode(mut self, input: ::std::option::Option<crate::types::TerminationMode>) -> Self {
        self.termination_mode = input;
        self
    }
    /// <p>The method to use to terminate the game session. Available methods include:</p>
    /// <ul>
    /// <li>
    /// <p><code>TRIGGER_ON_PROCESS_TERMINATE</code> – Sends an <code>OnProcessTerminate()</code> callback to the server process to initiate the normal game session shutdown sequence. At a minimum, the callback method must include a call to the server SDK action <code>ProcessEnding()</code>, which is how the server process signals that a game session is ending. If the server process doesn't call <code>ProcessEnding()</code>, this termination method won't be successful.</p></li>
    /// <li>
    /// <p><code>FORCE_TERMINATE</code> – Takes action to stop the server process, using existing methods to control how server processes run on an Amazon GameLift managed compute.</p><note>
    /// <p>This method is not available for game sessions that are running on Anywhere fleets unless the fleet is deployed with the Amazon GameLift Agent. In this scenario, a force terminate request results in an invalid or bad request exception.</p>
    /// </note></li>
    /// </ul>
    pub fn get_termination_mode(&self) -> &::std::option::Option<crate::types::TerminationMode> {
        &self.termination_mode
    }
    /// Consumes the builder and constructs a [`TerminateGameSessionInput`](crate::operation::terminate_game_session::TerminateGameSessionInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::terminate_game_session::TerminateGameSessionInput, ::aws_smithy_types::error::operation::BuildError>
    {
        ::std::result::Result::Ok(crate::operation::terminate_game_session::TerminateGameSessionInput {
            game_session_id: self.game_session_id,
            termination_mode: self.termination_mode,
        })
    }
}
